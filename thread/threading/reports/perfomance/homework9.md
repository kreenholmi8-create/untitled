# Отчёт по бенчмарку производительности файловых операций в Java

## 1. Описание проекта

Проект представляет собой Spring Boot приложение для сравнительного анализа трёх подходов к работе с файлами в Java: RandomAccessFile, FileChannel с ByteBuffer и Memory-Mapped Files (MappedByteBuffer).

**Технологический стек:** Java 21, Spring Boot 4.0.1, Maven, Lombok.

## 2. Тестовые данные

Генерируются записи о курсах валют (класс `CurrencyRate`) с полями: id, валютная пара, курс, объём, временная метка. Размер одной записи в бинарном формате — 108 байт. Генерация детерминирована (seed=42) для воспроизводимости. Тестирование проводилось на объёмах 10 000, 50 000 и 100 000 записей.

## 3. Результаты измерений

### 3.1. Запись данных (Throughput, записей/сек)

| Метод | 10 000 записей | 50 000 записей | 100 000 записей |
|-------|----------------|----------------|-----------------|
| RandomAccessFile | 28 249 | 32 830 | 33 602 |
| FileChannel | 370 370 | 833 333 | 1 063 830 |
| Memory-Mapped | 277 778 | 961 538 | 1 333 333 |

### 3.2. Последовательное чтение (Throughput, записей/сек)

| Метод | 10 000 записей | 50 000 записей | 100 000 записей |
|-------|----------------|----------------|-----------------|
| RandomAccessFile | 29 326 | 38 640 | 39 635 |
| FileChannel | 222 222 | 406 504 | 434 783 |
| Memory-Mapped | 344 828 | 450 450 | 458 716 |

### 3.3. Случайное чтение (10% от объёма)

| Метод | 1 000 записей | 5 000 записей | 10 000 записей |
|-------|---------------|---------------|----------------|
| RandomAccessFile | 38 462 | 34 483 | 33 113 |
| Memory-Mapped | 25 641 | 28 090 | 37 879 |

### 3.4. Пиковое потребление памяти (100 000 записей)

| Метод | Операция | Пик памяти (МБ) |
|-------|----------|-----------------|
| RandomAccessFile | Запись | ~41.5 |
| FileChannel | Запись | ~53.6 |
| Memory-Mapped | Запись | ~52.2 |

## 4. Анализ результатов

**Производительность записи:** Memory-Mapped Files показал лучшие результаты на больших объёмах (до 1.33 млн записей/сек), превосходя FileChannel примерно на 25%. RandomAccessFile отстаёт в 30-40 раз из-за отсутствия буферизации и множества системных вызовов.

**Последовательное чтение:** Memory-Mapped Files лидирует благодаря тому, что данные отображаются непосредственно в адресное пространство процесса, минуя копирование между буферами ядра и пользовательского пространства.

**Случайное чтение:** Результаты неоднозначны. На малых объёмах RandomAccessFile показывает лучшую производительность, однако при масштабировании Memory-Mapped Files догоняет и превосходит его за счёт эффективного кэширования страниц ОС.

**Потребление памяти:** FileChannel и Memory-Mapped Files потребляют больше памяти из-за буферизации. При этом Memory-Mapped не всегда показывает максимальный пик, поскольку часть данных управляется виртуальной памятью ОС и не учитывается в heap JVM.

## 5. Рекомендации по применению

**RandomAccessFile** подходит для небольших файлов, редких операций и сред с жёсткими ограничениями памяти. Прост в использовании, но неэффективен при интенсивном I/O.

**FileChannel + ByteBuffer** — универсальное решение с хорошим балансом производительности и контроля над ресурсами. Рекомендуется как основной подход для большинства задач.

**Memory-Mapped Files** оптимален для больших файлов с частым доступом при достаточном объёме RAM. Риски: потенциальный OutOfMemoryError, сложность явного освобождения ресурсов (unmapping), проблемы при конкурентном доступе.

## 6. Выводы

Бенчмарк подтвердил теоретические ожидания: буферизированные подходы (FileChannel, Memory-Mapped) значительно превосходят RandomAccessFile по производительности. Выбор метода должен определяться конкретным сценарием использования с учётом объёма данных, частоты операций и доступных ресурсов.
