## 1. Цель работы

Цель работы — сравнить производительность и поведение виртуальных потоков и традиционных платформенных потоков в Java при выполнении большого числа однотипных задач, имитирующих неблокирующий ввод‑вывод, а также познакомиться с подходом структурированной конкуренции через `StructuredTaskScope`.

---

## 2. Описание реализации

### 2.1. Создание задач

Была реализована единая «задача», которая:

1. Выводит идентификатор задачи и имя потока, в котором она выполняется:
   ```java
   String threadName = Thread.currentThread().getName();
   System.out.printf("Задача %d выполняется в потоке: %s%n", taskId, threadName);
   ```
   Для того чтобы не засорять консоль, фактически вывод ограничен первыми несколькими задачами (0–9).

2. Иммитирует неблокирующую I/O‑операцию с помощью `Thread.sleep(10)`, что в контексте лабораторной служит аналогом ожидания ответа от сети или диска:
   ```java
   try {
       Thread.sleep(IO_EMULATION_MS); // IO_EMULATION_MS = 10
   } catch (InterruptedException e) {
       Thread.currentThread().interrupt();
   }
   ```

Общее число задач задаётся константой:
```java
private static final int TASK_COUNT = 10_000;
```

### 2.2. Запуск задач на виртуальных потоках

Для запуска задач на виртуальных потоках использовался следующий подход:

```java
for (int i = 0; i < TASK_COUNT; i++) {
    int taskId = i;
    Thread vThread = Thread.ofVirtual().start(() -> taskBody(taskId));
    threads.add(vThread);
}

for (Thread t : threads) {
    t.join();
}
```

Ключевые моменты:

- `Thread.ofVirtual().start(...)` создаёт виртуальный поток — лёгкий поток уровня JVM.
- Все 10 000 задач запускаются параллельно на виртуальных потоках.
- После запуска программа ожидает завершения всех потоков через `join()`.

Во время выполнения для первых задач выводится имя потока (в вашем выводе оно оказалось пустым — вероятно, в версии кода, которую вы запускали, строка с именем потока не была корректно выведена или была изменена).

### 2.3. Запуск задач на платформенных потоках

Аналогичный набор задач запускается на «классических» потоках:

```java
for (int i = 0; i < TASK_COUNT; i++) {
    int taskId = i;
    Thread thread = new Thread(() -> taskBody(taskId));
    thread.start();
    threads.add(thread);
}

for (Thread t : threads) {
    t.join();
}
```

Особенности:

- Используется `new Thread(...)` — создаётся полноценный поток операционной системы с собственным стеком и ресурсами.
- Также запускается 10 000 потоков, после чего происходит ожидание их завершения.

В выводе видно, что имена платформенных потоков отображаются в стандартном формате:
```text
Задача 0 выполняется в потоке: Thread-0
Задача 1 выполняется в потоке: Thread-1
...
Задача 9 выполняется в потоке: Thread-9
```

### 2.4. Использование StructuredTaskScope с виртуальными потоками

Третий вариант запуска использует структурированную конкуренцию (`StructuredTaskScope`) из Loom:

```java
try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {

    for (int i = 0; i < TASK_COUNT; i++) {
        int taskId = i;
        scope.fork(() -> {
            taskBody(taskId);
            return null;
        });
    }

    scope.join(); // ждём завершения всех
    scope.throwIfFailed(e -> new ExecutionException("Ошибка в одной из задач", e));
}
```

Характеристики:

- `scope.fork(...)` по умолчанию создаёт виртуальные потоки, но уже управляет ими в рамках «области» (scope).
- `ShutdownOnFailure` означает, что при первой ошибке остальные задачи будут отменены.
- `join()` гарантирует, что метод вернётся только после завершения всех задач (или их отмены).
- `throwIfFailed(...)` позволяет централизованно обработать исключения.

В вашем выводе при запуске через `StructuredTaskScope` имена потоков также не были напечатаны (оставались пустыми), что связано с текущим вариантом кода вывода, но логика выполнения задач при этом сохраняется.

---

## 3. Экспериментальные результаты

Вывод программы:

```text
=== Сравнение виртуальных и платформенных потоков ===
Количество задач: 10000
Эмуляция I/O (ms): 10

... (вывод первых 10 задач для каждого варианта) ...

Время выполнения на виртуальных потоках: 222 ms
----------------------------------------------------
Время выполнения на платформенных потоках: 1656 ms
----------------------------------------------------
Время выполнения в StructuredTaskScope (виртуальные потоки): 107 ms
```

Сводная табличка:

| Количество задач | Имитация I/O, ms | Тип запуска                                    | Время выполнения, ms |
|------------------|------------------|------------------------------------------------|----------------------|
| 10 000           | 10               | Виртуальные потоки (`Thread.ofVirtual().start`) | 222                  |
| 10 000           | 10               | Платформенные потоки (`new Thread().start`)     | 1656                 |
| 10 000           | 10               | Виртуальные потоки + `StructuredTaskScope`      | 107                  |

По одному прогону видно:

- Платформенные потоки оказались примерно в 7,5 раз медленнее, чем виртуальные.
- Использование `StructuredTaskScope` с виртуальными потоками дало ещё более быстрое завершение (порядка 100 ms). Это объясняется тем, что JVM может эффективнее управлять жизненным циклом виртуальных потоков внутри структурированного scope и уменьшать накладные расходы.

---

## 4. Объяснение работы с виртуальными потоками и StructuredTaskScope

### 4.1. Виртуальные потоки

Виртуальные потоки:

- реализуются на уровне JVM и мультиплексируются поверх ограниченного пула платформенных потоков;
- очень дёшевы в создании и уничтожении;
- позволяют без особых накладных расходов запускать десятки и сотни тысяч конкурентных задач, особенно если они много времени проводят в ожидании (I/O).

В данной работе это видно по времени выполнения 10 000 задач с `Thread.sleep(10)`:

- виртуальные потоки — около 222 ms;
- платформенные — 1656 ms.

### 4.2. StructuredTaskScope

`StructuredTaskScope` реализует принцип структурированной конкуренции:

- все конкурентные задачи создаются и живут внутри определённого блока кода (scope);
- при выходе из scope гарантируется, что все подзадачи завершены или корректно отменены;
- ошибка в одной задаче может служить сигналом для отмены остальных (вариант `ShutdownOnFailure`);
- исключения собираются и обрабатываются централизованно.

Практические преимущества:

- проще понимать жизненный цикл задач — они не «висят» произвольно в системе;
- снижается риск утечек потоков;
- упрощается обработка ошибок и отмена задач.

В лабораторной работе использование `StructuredTaskScope` показало наилучшее время выполнения (около 107 ms).

---

## 5. Итоговые выводы

1. Виртуальные потоки существенно эффективнее традиционных платформенных потоков при большом количестве задач (10 000) с ожиданием (эмуляцией I/O):
   - меньшее время выполнения;
   - потенциально более экономное использование памяти и ресурсов ОС.

2. Платформенные потоки при таком количестве задач показывают значительно худшую производительность, так как каждый поток — это отдельный поток ОС, что ведёт к заметным накладным расходам на создание, переключение контекста и память.

3. Использование `StructuredTaskScope` в связке с виртуальными потоками:
   - ещё больше упрощает управление группой задач;
   - обеспечивает структурированный жизненный цикл;
   - даёт лучшие показатели времени выполнения в эксперименте.

4. В контексте многозадачных приложений, выполняющих большое количество I/O‑ориентированных задач, виртуальные потоки и `StructuredTaskScope` представляют собой более удобный и производительный подход по сравнению с классическими платформенными потоками.
